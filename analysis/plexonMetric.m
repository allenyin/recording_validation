function [signals, waveformData, refSpikeTimes, dataSpikeTimes, binnedXcorr, VPDist, VRDist, SchreiberDist]...
        = plexonMetric(data, reference, binSize, ADchannel, minPeakHeight, varargin)
    
% Plot and compare the measured Plexon data against a reference signal.
%
% Inputs:
%   data - name of the saved plexon file, without file extension
%   reference - currently should only be signal generated by
%               "Noisy Spike Generator MATLAB Software v1.1" by Leslie Smith and
%               Nhamoinesu Mtetwa.
%               The named mat file contains variables r1, signals, and target. Details
%               given in the software manual.
%   ADchannel - Channel of plexon that contains the analog signal
%   minPeakHeight - threshold for peak finding to locate spike in analog signal
%
% Options:
%   'plotAnalog' - Will only plot the analog traces, no analysis done.
%
%  Outputs:
%   signals - reference waveform signal, original
%   waveformData - wireless recording waveform data, normalized to [-1,1].
%   refSpikeTimes - spike times of reference signal, after aligning the first peak with that of recording.
%   dataSpikeTimes - spike times of wireless recording, after aligning the first with that of reference.
%   binnedXcorr - struct containing d_B and acor_lag. d_B is binned distance 
%                 acor_lag is a cell-array of the cross-correlation of the binned firing rates.
%   VPDist - Victor-purpura distances.
%   VRDist - Van Rossum distances.
%   SchreiberDist - Schreiber distances. 
%
% Note that it is necessary to plot the raw traces first and then check the peak levels to establish a
% reasonable level for peak finding.
   
    assert(nargin>=5, 'Not enough arguments! Requires data, reference, binSize, ADchannel, minPeakHeight');
    plotAnalog = false;
    if nargin>5
        for i=1:(nargin-5)
            if ischar(varargin{i})
                switch lower(varargin{i}),
                    case 'plotanalog'
                        plotAnalog = true;
                end
            end
        end
    end

    Fs_plexon = 20000;     % Plexon sampling frequency, in Hz
    Fs_ref = 31250;        % Reference sampling frequency, in Hz

    if isequal(class(reference), 'char')
        % Entered a file name
        load(reference);                        % r1, signals, target
    elseif isequal(class(reference), 'struct')
        % Otherwise it's an object
        signals = reference.signals;
        target = reference.target;
    end

    refSpikeTimes = target.targettimes.';   % in seconds, convert to column vector

    % Load plexon data
    waveformFile = sprintf('%s_analog.mat', data);
    spikeFile = sprintf('%s_spkwav.mat', data);
    load(waveformFile);
    load(spikeFile);

    % Time vector for plexon
    eval(['waveformData=double(', ADchannel, ');']);
    waveformData = waveformData./max(abs(waveformData));
    eval(['plexTime=double(', ADchannel, '_ts);']);

    % interpolate waveformData to 31250Hz.
    waveformData = interp1(plexTime, waveformData, plexTime(1):1/Fs_ref:plexTime(end));

    % Plexon recording might have extra stuff in the end due to manually stopping audio signal.
    % Cut this off manually. Make sure the waveform is not more than 2 seconds longer than reference.
    maxLen = numel(signals)+2*Fs_ref;
    maxTime = maxLen/Fs_ref;
    if numel(waveformData) > maxLen,
        waveformData = waveformData(1:maxLen);
    end

    [refFirstPeak, dataFirstPeak] = align_by_waveform_firstSpike(waveformData, signals, Fs_ref, refSpikeTimes, minPeakHeight, 'Plexon Reference and Recording');

    if plotAnalog,
        refSpikeTimes = []; dataSpikeTimes = [];
        binnedXcorr = []; VPDist = []; VRDist = []; SchreiberDist = [];
        return;
    end

    % Now get the Plexon spike timings
    timelag = (dataFirstPeak-refFirstPeak)/Fs_ref;
    dataSpikeTimes = sig001a - timelag;     % shift by the signal offset
    % make sure we don't include extra spikes from not stopping audio signal fast enough.
    if ~find(dataSpikeTimes > (maxTime - timelag)),
        dataSpikeTimes = dataSpikeTimes(1:min(find(dataSpikeTimes > (maxTime - timelag))));
    end

    [binnedXcorr, VPDist, VRDist, SchreiberDist] = ...
        compareSpikeTimes(refSpikeTimes, dataSpikeTimes, binSize, 'Plexon');
end





