function [signals, waveformData, refSpikeTimes, dataSpikeTimes, binnedXcorr, VPDist, VRDist, SchreiberDist]...
          = wirelessMetric(data, reference, binSize, minPeakHeight, varargin)

% Plot and compare the measured wireless data against
% a reference signal.
%
% Inputs:
%   data - name of the saved wireless file, without file extension.
%   reference - currently should only be signal generated by
%                 "Noisy Spike Generator MATLAB Software v1.1" by Leslie Smith and Nhamoinesu Mtetwa
%                 The named mat file contains variables r1, signals, and target. Details  given in the
%                 manual for the software.
%   binSize - time scale at which we are running metric comparisons. In ms.
%   minPeakHeight - threshold of peak finding to locate spike in analog signal
%
% Options:
%   'plotAnalog' - Will only plot the analog traces, no analysis done.
%
% Outputs:
%   signals - reference waveform signal, original
%   waveformData - wireless recording waveform data, normalized to [-1,1].
%   refSpikeTimes - spike times of reference signal, after aligning the first peak with that of recording.
%   dataSpikeTimes - spike times of wireless recording, after aligning the first with that of reference.
%   binnedXcorr - struct containing d_B and acor_lag. d_B is binned distance.
%                 acor_lag is a cell-array of the cross-correlation of the binned firing rates.
%   VPDist - Victor-purpura distances.
%   VRDist - Van Rossum distances.
%   SchreiberDist - Schreiber distances. 

    assert(nargin>=4, 'Not enough arguments! Requires data, reference, binSize, minPeakHeight');
    plotAnalog = false;
    if nargin>4
        for i=1:(nargin-4)
            if ischar(varargin{i})
                switch lower(varargin{i}),
                    case 'plotanalog'
                        plotAnalog = true;
                end
            end
        end
    end

    Fs = 31250;         % Wireless sampling frequency
    if isequal(class(reference), 'char')
        % Entered a file name
        load(reference);    % r1, signals, target
    elseif isequal(class(reference), 'struct')
        % Otherwise it's an object 
        signals = reference.signals;
        target = reference.target;
    end

    refSpikeTimes = target.targettimes.';  % in seconds, convert to column

    % Load wireless data
    waveformFile = sprintf('%s.nlg', data);
    spikeFile = sprintf('%s.mat', data);

    % waveform data
    waveformData = plot_raw_channels(waveformFile, 'plot', true);
    waveformData = waveformData(1,:)./128;  % only first channel is sorted, normalize to [-1,1]

    % Might have extra stuff in the back due to manually stopping the recording. Allow no more than 2s
    % extra
    maxLen = numel(signals) + 2*Fs;
    maxTime = maxLen/Fs;
    if numel(waveformData) > maxLen,
        waveformData = waveformData(1:maxLen);
    end

    [refFirstPeak, dataFirstPeak] = align_by_waveform_firstSpike(waveformData, signals, Fs, ...
                                        refSpikeTimes, minPeakHeight, 'Wireless Reference and Recording');
    if plotAnalog,
        refSpikeTimes = []; dataSpikeTimes = [];
        binnedXcorr = []; VPDist = []; VRDist = []; SchreiberDist = [];
        return;
    end

    % Load spike data, this loads the following into workspace
    %   spike_ch   - Array with channel# for which a spike has been detected. 
    %   spike_ts   - Array of spike times. Indexes time or mstimer. Spikes are
    %                sorted on headstage but timestamped on the bridge by receiving time.
    %                Same length as spike_ch.
    %   spike_unit - Same length of spike_ch, tells which unit on the given channel has spike.
    %   strobe_rx  - Time when strobe is received.
    %   strobe_tx  - Time when stribe is transmitted.
    %   mstimer    - Hardware clock on bridge, runs at 9155.273438Hz. One entry per packet received.
    %                Used for timestamping spikes, i.e. when a packet with a spike is received on by
    %                the bridge, the packet rx-time is used for spike time. Probably lags the actual
    %                spike detection time by around 768us
    %   time       - Wall time within the client, synchronous to any BMI3 client talking to gtkclient.
    %                One time per packet received by gtkclient. Does not have sufficient resolution for
    %                spikes, may arrive out of order.
    %   track_frame
    %
    % In validation, only channel 1 is sorted, so all spikes corresponds to that channel

    load(spikeFile);
    f_mstimer = 9155.273438;        % Hz
    mstimer = double(mstimer);      % convert from uint32 to double
    spike_ts = double(spike_ts);    % convert from uint32 to double    

    [refSpikeTimes, dataSpikeTimes] = ...
        extractSpikeTimes(f_mstimer, mstimer, spike_ts, refSpikeTimes, Fs, dataFirstPeak, refFirstPeak);

    [binnedXcorr, VPDist, VRDist, SchreiberDist] = ...
    compareSpikeTimes(refSpikeTimes, dataSpikeTimes, binSize, 'Wireless');

end

function [refSpikeTimes, dataSpikeTimes] = extractSpikeTimes(f_mstimer, mstimer, spike_ts, refSpikeTimes, Fs, dataFirstPeak, refFirstPeak)
    
    % process mstimer to start at 0
    mstimer= mstimer - mstimer(1);
    mstimer= mstimer/f_mstimer;         % timer in seconds

    % now align the mstimerNew with the reference timer using the peak times
    mstimer= mstimer-dataFirstPeak/Fs;
    dataSpikeTimes = mstimer(spike_ts); % spike times in bridge time
    refSpikeTimes = refSpikeTimes - refFirstPeak/Fs;
end

function align_by_waveform_xcorr(waveformData, signals, Fs)

    % Plot original data together with reference
    figure;
    plot(signals); hold on;
    plot(waveformData, 'r');
    ylim([-1.3,1.3]);
    title('Wireless: Reference and Recording');

    % analyze xcorrelation to match the beginning of reference to 
    % the recording -- not necessarily the same length due to system lag.
    [acor, lag] = xcorr(signals, waveformData);
    [~, I] = max(abs(acor));
    lagDiff = lag(I);
    figure;
    plot(signals); hold on;
    recordingEnd = min([(-lagDiff+numel(signals)-1),numel(waveformData)]);
    plot(waveformData(-lagDiff:recordingEnd), 'r');
    ylim([-1.3,1.3]);
    title('Wireless: Reference and Recording aligned by XCorr');

    fprintf('Align by waveform: recording lags reference by %0.5f seconds\n', -lagDiff/Fs);
    fprintf('                   recording lags reference by %d samples\n', -lagDiff);
end
